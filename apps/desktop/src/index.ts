import { app, BrowserWindow, ipcMain } from 'electron'
import * as path from 'path'
import { createMenu } from './menu'
import { execSync, spawn } from 'child_process'
import si from 'systeminformation'

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
// Remove or ignore MAIN_WINDOW_WEBPACK_ENTRY and MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY

const isDev = process.env.NODE_ENV === 'development'
let ollamaProcess: ReturnType<typeof spawn> | null = null

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
	app.quit()
}

const createWindow = (): void => {
	// Create the browser window.
	const mainWindow = new BrowserWindow({
		width: 1000,
		height: 600,
		titleBarStyle: 'hidden',
		webPreferences: {
			// In production you could still set up a preload if needed:
			// preload: path.join(__dirname, 'preload.js')
		},
	})

	if (isDev) {
		mainWindow.loadURL('http://localhost:5173')
	} else {
		// Changed production path to remove extra "src" folder
		const indexPath = path.join(process.resourcesPath, 'dist-web', 'index.html')
		mainWindow.loadFile(indexPath)
	}

	if (isDev) {
		mainWindow.webContents.openDevTools()
	}

	createMenu(mainWindow)



}

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', createWindow)

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
	if (process.platform !== 'darwin') {
		app.quit()
	}
})

app.on('activate', () => {
	// On OS X it's common to re-create a window in the app when the
	// dock icon is clicked and there are no other windows open.
	if (BrowserWindow.getAllWindows().length === 0) {
		createWindow()
	}
})

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.



// Add this before the other IPC handlers
ipcMain.handle('system-info-get', async () => {
	try {
		const [osInfo, cpu, mem, disk, graphics] = await Promise.all([
			si.osInfo(),
			si.cpu(),
			si.mem(),
			si.fsSize(),
			si.graphics()
		])

		return {
			os: {
				platform: osInfo.platform,
				distro: osInfo.distro,
				release: osInfo.release,
				arch: osInfo.arch
			},
			cpu: {
				manufacturer: cpu.manufacturer,
				brand: cpu.brand,
				cores: cpu.cores
			},
			memory: {
				total: mem.total,
				free: mem.free
			},
			disk: {
				total: disk[0]?.size || 0,
				free: disk[0]?.available || 0
			},
			graphics: {
				controllers: graphics.controllers.map(ctrl => ({
					model: ctrl.model,
					vram: ctrl.vram
				}))
			}
		}
	} catch (error) {
		console.error('Error getting system info:', error)
		return null
	}
})

// Register IPC handlers
ipcMain.handle('ollama-install-check', () => {
	try {
		execSync('ollama --version', { stdio: 'ignore' })
		return true
	} catch {
		return false
	}
})

ipcMain.handle('ollama-server-toggle', async (_, start) => {
	try {
		if (start) {
			if (!ollamaProcess) {
				ollamaProcess = spawn('ollama', ['serve'], {
					detached: false,
					stdio: 'pipe'
				})

				ollamaProcess.on('error', (error) => {
					console.error('Failed to start ollama:', error)
					ollamaProcess = null
				})

				// Wait a bit for the server to start
				await new Promise(resolve => setTimeout(resolve, 1000))
			}
		} else {
			if (ollamaProcess) {
				ollamaProcess.kill()
				ollamaProcess = null
			} else {
				execSync('pkill ollama', { stdio: 'ignore' })
			}
		}
		return true
	} catch (error) {
		console.error('Error toggling server:', error)
		return false
	}
})

ipcMain.handle('ollama-model-download', async (_, modelId) => {
	try {
		const result = execSync(`ollama download ${modelId}`, { stdio: 'pipe' })
		return result.toString()
	} catch (error) {
		if (error instanceof Error) {
			return error.message
		}
		return 'An unknown error occurred (ollama-model-download)'
	}
})

ipcMain.handle('ollama-model-remove', async (_, modelId) => {
	try {
		const result = execSync(`ollama rm ${modelId}`, { stdio: 'pipe' })
		return result.toString()
	} catch (error) {
		if (error instanceof Error) {
			return error.message
		}
		return 'An unknown error occurred (ollama-model-remove)'
	}
})



// Clean up when app quits
app.on('before-quit', () => {
	// if (ollamaProcess) {
	// 	ollamaProcess.kill();
	// 	ollamaProcess = null;
	// }
})
